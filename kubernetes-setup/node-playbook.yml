---
- hosts: all
  become: true

  vars:
    proxy_env:
      http_proxy: http://10.200.10.1:1087
      https_proxy: http://10.200.10.1:1087
      no_proxy: localhost,127.0.0.1,10.200.10.1,10.0.0.10,master,10.0.0.11,node-1,10.0.0.12,node-2,10.96.0.0/12,10.0.2.15,192.168.0.0/16
    
    kubelet_version: 1.25.5-00

  tasks:

  - name: add line of registry.local to /etc/hosts
    lineinfile:
      path: /etc/hosts
      line: 10.200.10.1 registry.local
      owner: root
      group: root
      mode: '0644'

  - name: Setup proxy in /etc/environment file
    ansible.builtin.blockinfile:
      path: /etc/environment
      block: |
        HTTP_PROXY={{ proxy_env.http_proxy }}
        HTTPS_PROXY={{ proxy_env.https_proxy }}
        NO_PROXY={{ proxy_env.no_proxy }}

  - name: Setup proxy in /etc/apt/apt.conf.d/proxy.conf file for apt-get
    ansible.builtin.blockinfile:
      path: /etc/apt/apt.conf.d/proxy.conf
      block: |
        Acquire::http::Proxy "{{ proxy_env.http_proxy }}";
        Acquire::https::Proxy "{{ proxy_env.https_proxy }}";
      create: yes

  # - name: Copy local tools to remote host
  #   ansible.builtin.copy:
  #     src: ./shared-data/nerdctl-1.0.0-linux-amd64.tar.gz
  #     dest: /home/vagrant/
  #     owner: vagrant
  #     group: vagrant
  #     mode: '0644'

  # TODO:
  - name: Remove swapfile from /etc/fstab
    ansible.builtin.command: 
      cmd: sed -i 's/^\/swap/#\/swap/' /etc/fstab

  # TODO: 
  - name: Disable swap
    command: swapoff -a
    when: ansible_swaptotal_mb > 0

  - name: Add overlay & br_netfilter in /etc/modules-load.d/k8s.conf
    ansible.builtin.blockinfile:
      path: /etc/modules-load.d/k8s.conf
      block: |
        overlay
        br_netfilter
      create: yes

  - name: Load the overlay module
    modprobe:
      name: overlay
      state: present

  - name: Load the br_netfilter module
    modprobe:
      name: br_netfilter
      state: present

  - name: Write bridge-netfilter and ip-forward system variables
    copy:
      content: |
        net.bridge.bridge-nf-call-ip6tables = 1
        net.bridge.bridge-nf-call-iptables  = 1
        net.ipv4.ip_forward                 = 1
      dest: /etc/sysctl.d/k8s.conf
      # mode: '666'

  - name: Set ip forwarding on in /proc and in the sysctl file and reload if necessary
    ansible.posix.sysctl:
      name: net.ipv4.ip_forward
      value: '1'
      sysctl_set: yes
      state: present
      reload: yes

  - name: Set net.bridge.bridge-nf-call-ip6tables to 1 in the sysctl file and reload if necessary
    ansible.posix.sysctl:
      name: net.bridge.bridge-nf-call-ip6tables
      value: '1'
      sysctl_set: yes
      state: present
      reload: yes

  - name: Set net.bridge.bridge-nf-call-iptables to 1 in the sysctl file and reload if necessary
    ansible.posix.sysctl:
      name: net.bridge.bridge-nf-call-iptables
      value: '1'
      sysctl_set: yes
      state: present
      reload: yes

  - name: Uninstall old versions of 
    ansible.builtin.apt:
      pkg:
      - docker
      - docker-engine
      - docker.io
      - containerd
      - runc
      state: absent

  - name: Run the equivalent of "apt-get update" as a separate step
    ansible.builtin.apt:
      update_cache: yes

  - name: Install packages of apt-transport-https, ca-certificates and curl
    ansible.builtin.apt:
      pkg:
      - apt-transport-https
      - ca-certificates
      - curl
      - gnupg
      - lsb-release

  - name: Create a directory if /etc/apt/keyrings does not exist
    ansible.builtin.file:
      path: /etc/apt/keyrings
      state: directory
      # mode: '0755'

  - name: Add Dockerâ€™s official GPG key
    ansible.builtin.shell: |
      curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

  - name: Set up the Docker repository
    ansible.builtin.shell: |
      echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list

  - name: Run the equivalent of "apt-get update" as a separate step
    ansible.builtin.apt:
      update_cache: yes

  - name: To install the latest version of containerd
    ansible.builtin.apt:
      pkg:
      - containerd.io

  - name: Create a directory if /etc/containerd does not exist
    ansible.builtin.file:
      path: /etc/containerd
      state: directory

  - name: Copy local config.toml to remote host
    ansible.builtin.copy:
      src: ./shared-data/config.toml
      dest: /etc/containerd/config.toml

  - name: Create a directory if /etc/containerd/certs.d/docker.io does not exist
    ansible.builtin.file:
      path: /etc/containerd/certs.d/docker.io
      state: directory
  
  - name: Setup proxy for kubeadm
    ansible.builtin.shell: |
      systemctl set-environment HTTP_PROXY={{ proxy_env.http_proxy }}
      systemctl set-environment HTTPS_PROXY={{ proxy_env.https_proxy }}
      systemctl set-environment NO_PROXY={{ proxy_env.no_proxy }}

  - name: Reload service containerd, in all cases
    ansible.builtin.systemd:
      name: containerd
      state: restarted
      enabled: yes

  - name: Download the Google Cloud public signing key
    ansible.builtin.shell: |
      curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg  

  - name: Add the Kubernetes apt repository
    ansible.builtin.shell: |
      echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | tee /etc/apt/sources.list.d/kubernetes.list

  - name: Run the equivalent of "apt-get update" as a separate step
    ansible.builtin.apt:
      update_cache: yes

  - name: Install packages of kubelet, kubeadm and kubectl
    ansible.builtin.apt:
      pkg:
      - kubelet={{ kubelet_version }}
      - kubeadm={{ kubelet_version }}
      - kubectl={{ kubelet_version }}
      allow_change_held_packages: true

  - name: Restart kubelet
    ansible.builtin.systemd:
      name: kubelet
      state: restarted
      enabled: yes

  - name: Copy the join command to server location
    copy: src=join-command dest=/tmp/join-command.sh mode=0777

  - name: Join the node to cluster
    command: sh /tmp/join-command.sh

  handlers:
    - name: docker status
      service: name=docker state=started
